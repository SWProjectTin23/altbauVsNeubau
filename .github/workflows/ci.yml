name: Docker Compose Application Startup Test

# This workflow builds Docker images and performs a sanity check by starting the services briefly.
# It is triggered on pushes and pull requests to the main branch.
# It also allows manual triggering via the GitHub UI.

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch: # Allows manual triggering from the GitHub Actions tab

jobs:
  test-application-services:
    # This job runs on a GitHub-hosted Ubuntu runner, which comes with Docker and Docker Compose pre-installed.
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4 # Fetches your repository's code onto the runner

      - name: Set up Docker Buildx
        # This action sets up Docker Buildx, which provides enhanced build capabilities.
        uses: docker/setup-buildx-action@v3

      # This action ensures Docker Compose is correctly set up and available in the PATH.
      # It's a robust way to handle Docker Compose versions and ensures compatibility.
      - name: Set up Docker Compose
        uses: crazy-max/ghaction-docker-compose@v3
        with:
          version: latest # Ensures the latest stable version of Docker Compose is used

      - name: Build and Start Services (excluding github-runner)
        run: |
          echo "Starting Docker Compose services (backend, frontend, db)..."
          # IMPORTANT: Using 'docker compose' (with a space) for Docker Compose V2 CLI syntax.
          # --build ensures images are built if they don't exist or are outdated.
          # --exclude-service github-runner prevents attempting to start the runner service,
          # which is only relevant for self-hosted deployment and not for this testing workflow.
          docker compose -f docker-compose.yml up -d --build --exclude-service github-runner
          echo "Services started. Waiting for them to become healthy..."

          # Give all services, especially the database, ample time to start and pass health checks.
          # This duration should be generous. Healthchecks defined in docker-compose.yml are crucial here.
          # A decent initial sleep helps avoid immediate failures before health checks can pass.
          sleep 60 # Adjust based on your service startup times.

      - name: Check Service Health with Retries
        run: |
          echo "Checking health status of backend, frontend, and database..."

          # Define an array of services to check along with their respective health check commands.
          # Ensure the ports and paths match your application's configuration in docker-compose.yml.
          declare -a SERVICES_TO_CHECK=(
            "db:pg_isready -h localhost -p 5432 -U ${DB_USER} -d ${DB_NAME}"
            "backend:curl -f http://localhost:5001/health" # Adjust port and path if different
            "frontend:curl -f http://localhost:3000"       # Adjust port and path if different, checks for successful HTTP response
          )

          ALL_SERVICES_HEALTHY=true

          for SERVICE_CHECK in "${SERVICES_TO_CHECK[@]}"; do
            # Split the string into SERVICE_NAME and CHECK_COMMAND
            IFS=':' read -r SERVICE_NAME CHECK_COMMAND <<< "$SERVICE_CHECK"
            echo "--- Checking health for service: $SERVICE_NAME ---"

            MAX_ATTEMPTS=15 # Total attempts to check the service (15 * 5 seconds = 75 seconds max wait per service)
            ATTEMPT=0
            SERVICE_READY=false

            while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
              if [ "$SERVICE_NAME" == "db" ]; then
                # For PostgreSQL, pg_isready requires the password via PGPASSWORD environment variable.
                # It's crucial that DB_PASSWORD is provided as a GitHub Secret.
                PGPASSWORD="${DB_PASSWORD}" $CHECK_COMMAND
              else
                $CHECK_COMMAND # Execute the curl command for backend/frontend
              fi

              if [ $? -eq 0 ]; then # Check if the command exited successfully (status code 0)
                echo "Service '$SERVICE_NAME' is healthy!"
                SERVICE_READY=true
                break # Exit the while loop if service is healthy
              else
                echo "Service '$SERVICE_NAME' not healthy yet. Retrying in 5 seconds... (Attempt $((ATTEMPT + 1))/$MAX_ATTEMPTS)"
                sleep 5 # Wait before the next retry
              fi
              ATTEMPT=$((ATTEMPT + 1))
            done

            if [ "$SERVICE_READY" = false ]; then
              echo "Error: Service '$SERVICE_NAME' did not become healthy within the expected time."
              ALL_SERVICES_HEALTHY=false
              # Display logs for the specific service that failed to help debugging
              # IMPORTANT: Using 'docker compose' (with a space)
              docker compose -f docker-compose.yml logs "$SERVICE_NAME"
              break # Exit the loop if any service fails, no need to check others
            fi
          done

          if [ "$ALL_SERVICES_HEALTHY" = false ]; then
            echo "One or more services failed their health checks. Displaying all Docker Compose logs and exiting with error."
            # IMPORTANT: Using 'docker compose' (with a space)
            docker compose -f docker-compose.yml logs # Display all logs if any service failed
            exit 1 # Fail the job
          else
            echo "All specified services passed their health checks successfully!"
          fi
        env:
          # These environment variables are passed to the 'run' command.
          # Ensure these secrets are configured in your GitHub repository's settings.
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }} # Used by PGPASSWORD for pg_isready
          DB_NAME: ${{ secrets.DB_NAME }}

      - name: Stop and remove services (Cleanup)
        # This step will always run, regardless of the success or failure of previous steps,
        # ensuring resources are cleaned up.
        if: always()
        run: |
          echo "Stopping and removing Docker Compose services..."
          # IMPORTANT: Using 'docker compose' (with a space)
          # --volumes removes named volumes declared in the compose file.
          # --remove-orphans removes containers for services not defined in the compose file.
          # '|| true' ensures this step doesn't fail the workflow if the services are already down.
          docker compose -f docker-compose.yml down --volumes --remove-orphans || true
          echo "Cleanup complete."