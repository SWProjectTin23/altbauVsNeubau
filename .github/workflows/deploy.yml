name: CI/CD Deployment to Self-Hosted Runner
# This GitHub Actions workflow deploys your application to a self-hosted runner using Docker Compose
# It is triggered on every push to the 'main' branch.

on:
  push:
    branches:
      - main # The workflow will be triggered on every push to the 'main' branch
  workflow_dispatch: # Allows manual triggering of the workflow from the GitHub Actions tab

jobs:
  deploy:
    runs-on: [self-hosted, linux, altbau_vs_neubau] # Specifies that the job should run on a self-hosted Linux runner

    steps:
    - name: Checkout Code
      uses: actions/checkout@v4 # Fetches your repository's code onto the runner

    - name: Set up Docker Compose and Deploy
      # Hier werden die Umgebungsvariablen aus den GitHub Secrets an diesen Schritt übergeben.
      # Docker Compose in diesem Schritt wird diese Variablen dann finden.
      env:
        DB_USER: ${{ secrets.DB_USER }}
        DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        DB_NAME: ${{ secrets.DB_NAME }}
        DB_PORT: ${{ secrets.DB_PORT }} # Falls DB_PORT auch als ENV erwartet wird
        
        # Diese GITHUB_ Variablen werden von Docker Compose im Workflow nicht direkt benötigt,
        # da sie für den Runner-Start selbst relevant sind. Aber wenn deine docker-compose.yml
        # sie in anderen Diensten referenziert, sollten sie hier auch übergeben werden.
        # Wenn nur der github-runner Dienst sie braucht, und der schon läuft, sind sie hier nicht zwingend.
        # Ich lasse sie hier zur Vollständigkeit, falls andere Dienste sie nutzen.
        REPO_URL: ${{ secrets.REPO_URL }}
        RUNNER_NAME: ${{ secrets.RUNNER_NAME }}
        ACCESS_TOKEN: ${{ secrets.ACCESS_TOKEN }}
        RUNNER_LABELS: ${{ secrets.RUNNER_LABELS }}

      run: |
        echo "Verifying Docker installation..."
        docker info # Überprüft die Docker-Installation und -Verbindung
        docker compose version # Überprüft die Docker Compose Plugin-Version

        echo "Deploying application using Docker Compose..."
        # Verwende 'docker compose' (ohne Bindestrich)
        docker compose -f docker-compose.yml down || true # Stoppt und entfernt Container, Netzwerke, Images und Volumes. '|| true' verhindert, dass der Schritt fehlschlägt, wenn die Container nicht existieren.
        
        echo "Pulling latest Docker images..."
        docker compose pull # Zieht die neuesten Images für die Dienste

        echo "Building Docker images..."
        docker compose build

        echo "Starting new containers..."
        docker compose up -d

        echo "Application deployed successfully!"
